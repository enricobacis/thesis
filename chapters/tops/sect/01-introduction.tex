\section{Introduction}\label{ms:sec:intro}

With the considerable advancements in IT solutions, users and companies are finding increasingly appealing to rely on external services for storing resources and making them available to others. In such contexts, a promising approach to enforce access control to externally stored resources is via encryption: resources are encrypted for storage and only authorized users have the keys that enable their decryption. There are several advantages that justify the use of encryption for enforcing access control. First, robust encryption has become computationally inexpensive, enabling its introduction in domains that are traditionally extremely sensitive to performance (like cloud-based applications and management of large resources). Second, encryption provides protection against the service provider itself, which - while trustworthy for providing access - cannot typically be considered authorized to know the content of the resources it stores ({\em honest-but-curious\/} scenario) and hence also to enforce access control. Third, encryption solves the need of having a trusted party for policy enforcement: resources enforce self-protection, since only authorized users, holding the keys, will be able to decrypt them.
 
One of the complex aspects in using encryption to enforce access control policy concerns access revocation. If granting an authorization is easy (it is sufficient to give the newly authorized user access to the key), revoking an authorization is a completely different problem. There are essentially two approaches to enforce revocation: {\em i)\/} re-encrypt the resource with a new key or {\em ii)\/} revoke access to the key itself. Re-encryption of the resource entails, for the data owner, downloading the resource, decrypting it and re-encrypting it with a new key, re-uploading the resource, and re-distributing the key to the users who still hold authorizations. If decryption, re-encryption, and even key management (for this specific context) can be considered a trivial issue, the remaining challenge is represented by the need to download and re-upload the resource, with a considerable overhead for the data owner. This overhead will continue to grow as usage of cloud resources grows, in particular in the context of emerging big data applications. The alternative approach of enforcing revocation on the resource by preventing access to the key with which the resource is encrypted cannot be considered a solution. As a matter of fact, it protects the key, not the resource itself, and it is inevitably fragile against a user who - while having been revoked from an access - has maintained a local copy of the key.

\medskip
\noindent{\bf Our approach.}
In this chapter, we present a novel approach to enforce access revocation that provides efficiency, as it does not require expensive upload/re-upload of (large) resources, and robustness, as it is resilient against the threat of users who might have maintained copies of the keys protecting resources on which they have been revoked access.

The basic idea of our approach is to provide an encrypted representation of the resources that guarantees complete interdependence ({\em mixing\/}) among the bits of the encrypted content. Such a guarantee is ensured by using different rounds of encryption, while carefully selecting their input to provide complete mixing, meaning that the value of each bit in the resulting encrypted content depends on every bit of the original plaintext content. In this way, unavailability of even a small portion of the encrypted version of a resource completely prevents the reconstruction of the resource or even of portions of it. Brute-force attacks guessing possible values of the missing bits are possible, but even for small missing portions of the encrypted resource, the required effort would be prohibitive.
The {\em all-or-nothing transform} (AONT)~\cite{r97} considers similar requirements, but the techniques proposed for it are not suited to our scenario, because they are based on the assumption that keys are not known to users, whereas in our scenario revoked users can know the encryption key and may plan ahead to locally store critical pieces of information.

Our approach trades off between the requirement to connect all bits of a resource (to provide the desired interdependency of the content), and the requirement to maintain fine grained access of the resource itself. This is a particular challenge due to the potentially huge size of the resources. To achieve this, we apply the idea of mixing content within portions of the resource, enforcing then revocation by overwriting encrypted bits in every such portion. Before mixing, our approach partitions the resource in different, equally sized, chunks, called {\em macro-blocks\/}. Then, as the name hints, it is based on the following concepts.

\begin{itemize}

\item {\em Mix:\/} the content of each macro-block is processed by  an iterative application of different encryption rounds together with  a carefully designed bit mixing, that ensures, at the end of the process, that every individual bit in the input has had impact on each of the bits in the encrypted output.

\item {\em Slice:\/} the mixed macro-blocks are sliced into fragments so that  fragments provide complete coverage of the resource content and each fragment represents a minimal (in terms of number of bits of protection, which we call {\em mini-block\/}) unit of revocation: lack of any single fragment of the resource completely prevents reconstruction of the resource or of portions of it.
\end{itemize}

To revoke access from a user, it is sufficient to re-encrypt one (any one) of the resource fragments with a new key not known to the user. The advantage is clear: re-encrypting a tiny chunk of the resource guarantees protection of the whole resource itself. Also, the cloud provider simply needs to provide storage functionality and is not required to play an active role for enforcing access control or providing user authentication. Our \name\ proposal is complemented with a convenient approach for key management that, based on key regression, avoids any storage overhead for key distribution.

%\medskip
%\noindent{\bf Outline.}
%The remainder of the paper is organized as follows. Section~\ref{ms:sec:mixslice} illustrates our approach to produce an encrypted representation with the desired guarantees. Section~\ref{ms:sec:revoke} presents the enforcement of access revocation. Section~\ref{ms:sec:security} discusses the effectiveness of our solution in providing revocation. Section~\ref{ms:sec:expe} illustrates our implementation and the extensive experimental evaluation confirming its advantages and applicability. Section~\ref{ms:sec:relwork} discusses related work. Finally, Section~\ref{ms:sec:conclu} presents our conclusions.
