\section{Related work}\label{ms:sec:relwork}

The idea of making the extraction of the information content of an encrypted resource dependent on the availability of the complete resource has been first explored by Rivest~\cite{r97}, who proposed the {\em all-or-nothing transform} (AONT). The AONT requires that the extraction of a resource where $n$ bits of its transformed form are missing should require to attempt all the possible $2^n$ combinations. The AONT can be followed by encryption to produce an {\em all-or-nothing encryption schema}. In~\cite{r97}, the author proposes the {\em package transform}, which realizes an AONT by applying a CTR mode using a random key \key{}. The ciphertext is then suffixed with the used key \key{} {\sc xor}-ed with a hash of all the previous encrypted message blocks. In this way, a modification on the encrypted message limits the ability to derive the encryption key. This technique works under the assumption that the user who wants to decrypt the resource has never accessed the key before, but fails in a scenario where the user had previously accessed the key and now the access must be prevented (i.e., revocation of privileges on encrypted files). The user, in fact, could have stored key \key{} and so she would be able (depending on the encryption mode used) to partially retrieve the plaintext. Key \key{} can be seen as a digest: it is compact and its storage allows a receiver to access the majority of the file, even if one of the blocks was destroyed.

Most approaches for efficient secure deletion~\cite{chhs13,dw10} rely on the fact that the key is a digest for a resource and its content can be securely deleted by deleting the specific disk location that stores a piece of information that permits to derive the key used to encrypt the resource. Such approaches are already used by commercial storage devices~\cite{standardInd} and recent proposals have considered the integration of such approaches with flexible policies~\cite{chhs13}. All these approaches are not applicable in our scenario, where the encrypted resource is stored on a server that does not have access to (and hence does not store) the key and it is the user who has to decrypt the resource. Making the encryption key unavailable to the user does not limit her access.

\new{
In~\cite{DBLP:journals/corr/KapustaMN17}, the authors propose an algorithm for data protection based on information dispersal and fragmentation. The approach is similar to Mix\&Slice (i.e., a first step for mixing and a second one for slicing), but a keyless algorithm based on a modification of Shamir's secret sharing \cite{Shamir:1979:SS:359168.359176} is used for the mixing. This has the disadvantage that each shard has the same size as the original data, thus incurring in significant storage overhead. The authors do not consider how to revoke access to previously authorized users.
} % end \new

Other approaches for enforcing access control in the cloud through encryption have been developed along two research lines: attribute-based encryption (ABE) and selective encryption approaches. ABE approaches (e.g.,~\cite{gpsw06,hn11,pbhsr05,ywrl10}) provide access control enforcement by ensuring that the key used to protect a resource can be derived only by the users that satisfy a given condition on their attributes (e.g., age, role). The main shortcoming of these solutions is due to their evaluation costs (they rely on public key encryption), and to the hardness in the support of revocations~\cite{hn11,ywrl10}. Approaches based on selective encryption (e.g.,~\cite{vldb07,tods10,hkd15}) assume to encrypt each resource with a key that only authorized users know or can derive. In this scenario, policy updates are then either managed by the data owner, with considerable overhead, or delegated to the server through over-encryption~\cite{vldb07,tods10}. Although over-encryption guarantees a prompt enforcement of policy updates and demonstrates to offer good performance, it requires stronger trust assumptions on the server, which must provide dedicated support. On the contrary, our technique can be used also if the server is completely unaware of its adoption.
